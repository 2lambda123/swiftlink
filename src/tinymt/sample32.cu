/**
 * @file sample32.cu
 *
 * @brief Sample main Program for CUDA 4.0
 *
 * <code>
 * command line:
 * sample32 filename num_block num_thread num_data
 * </code>
 * filename is name of output or concatenated outputs of tinymt32dc.
 *
 * </code>
 */
#include <stdio.h>
#include <cuda.h>
#include <stdint.h>
#include <errno.h>
#include <stdlib.h>
#include "test_tool.hpp"	/* my utility tools for CUDA */
#include "tinymt32_host.h"

/* command line arguments */
int num_data;
int block_num;
int thread_num;
char * filename;

/*
 * this prototype is needed if kernel program is in another file.
 */
__global__ void sample_single_sum_kernel(unsigned int* param_array,
					 float* sum_array,
					 int size);

void set_params(const char * filename, uint32_t *d_params, int thread_num);
float make_single_sum_random(uint32_t * d_params, int num_data,
			     int block_num, int thread_num, int verbose);
void make_report(int block_num, int thread_num, int num_data, float gputime);
void parse_opt(int argc, char **argv);
void error_message(char * pgm);

#if !defined(TEST)
int main(int argc, char** argv)
{
    int total_thread_num;
    int r;
    uint32_t *d_params;
    int device = 0;
    float gputime;

    ccudaSetDevice(device);
    parse_opt(argc, argv);
    total_thread_num = block_num * thread_num;
    
    ccudaMalloc((void**)&d_params, sizeof(uint32_t) * 3 * total_thread_num);
    
    r = num_data % total_thread_num;
    if (r != 0) {
	    num_data = num_data + total_thread_num - r;
    }
    
    set_params(filename, d_params, total_thread_num);
    
    gputime = make_single_sum_random(d_params,
				     num_data,
				     block_num,
				     thread_num,
				     1);
    
    make_report(block_num, thread_num, num_data, gputime);
    
    //finalize
    ccudaFree(d_params);
}
#else
/*
 * If TEST is defined, this program repeats the kernel call
 * changing block parameter and print elapsed time for
 * each kernel call.
 */
int main(int argc, char** argv)
{
    int total_thread_num;
    int r;
    uint32_t *d_params;
    int device = 0;
    float gputime;

    ccudaSetDevice(device);
    parse_opt(argc, argv);
    
    for (; block_num < 128; block_num++) {
	    total_thread_num = block_num * thread_num;
	    ccudaMalloc((void**)&d_params, sizeof(uint32_t) * 3 * total_thread_num);
	    r = num_data % total_thread_num;
	    if (r != 0) {
	        num_data = num_data + total_thread_num - r;
	    }
	
	    set_params(filename, d_params, total_thread_num);
	
	    gputime = make_single_sum_random(d_params,
					 num_data,
					 block_num,
					 thread_num,
					 0);
	
	    printf("%d, %d, %d, %f\n", num_data, block_num, thread_num, gputime);
	    ccudaFree(d_params);
    }
}
#endif

/**
 * This function reads parameters from file and sets them in device memory.
 * @param[in] params input, tinymt32 parameters.
 */
void set_params(const char * filename, uint32_t *d_params, int thread_num)
{
    const int host_size = sizeof(uint32_t) * 3 * thread_num;
    uint32_t * h_params;
    int rc;
    
    h_params = (uint32_t *)malloc(host_size);
    if (h_params == NULL) {
	    printf("failure in allocating host memory for status.\n");
	    exit(1);
    }
    
    // filename shoud be name of the file generated by TinyMT32DC.
    rc = tinymt32_set_params(filename, h_params, thread_num);
    if (rc != 0) {
	    printf("failure in reading parameters.\n");
	    free(h_params);
	    exit(1);
    }
    
    ccudaMemcpy(d_params,
		h_params,
		sizeof(uint32_t) * 3 * thread_num,
		cudaMemcpyHostToDevice);
    
    free(h_params);
}

/**
 * host function.
 * This function calls corresponding kernel function.
 *
 * @param[in] d_status kernel I/O data.
 * @param[in] num_data number of data to be generated.
 */
float make_single_sum_random(uint32_t * d_params, int num_data,
			     int block_num, int thread_num, int verbose)
{
    float * d_data;
    float * h_data;
    cudaError_t e;
    float gputime;
    cudaEvent_t start;
    cudaEvent_t end;
    int total_thread_num = block_num * thread_num;

    if (verbose) {
	    printf("generating single precision random numbers.\n");
    }
    
    // create timer
    ccudaEventCreate(&start);
    ccudaEventCreate(&end);
    // allocate output area of kernel function
    ccudaMalloc((void**)&d_data, sizeof(float) * total_thread_num);
    h_data = (float *) malloc(sizeof(float) * total_thread_num);
    
    if (h_data == NULL) {
	    printf("failure in allocating host memory for output data.\n");
	    exit(1);
    }
    
    // start timer
    ccudaEventRecord(start, 0);
    if (cudaGetLastError() != cudaSuccess) {
	    printf("error has been occured before kernel call.\n");
	    exit(1);
    }

    // kernel call
    sample_single_sum_kernel<<<block_num, thread_num>>>(
	    d_params, d_data, num_data / total_thread_num);
    
    cudaThreadSynchronize();

    e = cudaGetLastError();
    if (e != cudaSuccess) {
	    printf("failure in kernel call.\n");
	    printf("%s\n", cudaGetErrorString(e));
	    exit(1);
    }
    
    // stop timer
    ccudaEventRecord(end, 0);
    ccudaEventSynchronize(end);
    
    // copy output to host
    ccudaMemcpy(h_data,
		d_data,
		sizeof(float) * total_thread_num,
		cudaMemcpyDeviceToHost);
    
    // calculate elapsed time
    ccudaEventElapsedTime(&gputime, start, end);
    
    if (verbose) {
	    printf("sum of random numbers\n");
	    print_float_array(h_data, total_thread_num, 1);
    }
    
    // delete timer
    ccudaEventDestroy(start);
    ccudaEventDestroy(end);
    //free memories
    free(h_data);
    ccudaFree(d_data);
    
    return gputime;
}

void exit_message(char * pgm)
{
    printf("%s tinymt32dc_outputfile number_of_block number_of_thread", pgm);
    printf(" number_of_output\n");
    exit(1);
}

void parse_opt(int argc, char **argv)
{
    if (argc >= 5) {
	filename = argv[1];
	errno = 0;
	block_num = strtol(argv[2], NULL, 10);
	if (errno) {
	    exit_message(argv[0]);
	}
	if (block_num < 1) {
	    printf(" block_num should be grater than 0 :%d\n",
		   block_num);
	    exit(1);
	}
	thread_num = strtol(argv[3], NULL, 10);
	if (errno) {
	    exit_message(argv[0]);
	}
	if (thread_num < 1) {
	    printf("%s thread_num should be grater than 0 :%d\n",
		   argv[0], thread_num);
	    exit(1);
	}
	errno = 0;
	num_data = strtol(argv[4], NULL, 10);
	if (errno) {
	    exit_message(argv[0]);
	}
    } else {
	exit_message(argv[0]);
    }
}

void make_report(int block_num, int thread_num, int num_data, float gputime)
{
    printf("generated numbers: %d\n", num_data);
    printf("Processing time: %f(ms)\n", gputime);
    printf("Samples per second: %E\n", (num_data / (gputime * 0.001)));
}
